/**
 * Generated by orval v6.7.1 üç∫
 * Do not edit manually.
 * Habit App
 * Habit App made by Oybek Alimatov
 * OpenAPI spec version: 1.0.0
 */
import axios,{
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery,
  useMutation,
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from 'react-query'
import {
  rest
} from 'msw'
import {
  faker
} from '@faker-js/faker'
export interface EditHabitInput {
  title: string;
  isoWeekdays: number[];
}

export interface UpdateHabitCompletedDatesInput {
  habitId: string;
  completedDates: number[];
}

export interface CreateHabitInput {
  _id: string;
  title: string;
  userId: string;
  isoWeekdays: number[];
  dateCreated: number;
  completedDates: number[];
  archived: boolean;
}

export interface Habit {
  _id: string;
  userId: string;
  title: string;
  isoWeekdays: number[];
  dateCreated: number;
  completedDates: number[];
  archived: boolean;
}

export interface User {
  _id: string;
  email: string;
  password?: string;
  isTemp: boolean;
  dateCreated: number;
}

export interface GoogleAuthInput {
  tempUserId: string;
  email: string;
}

export interface RegisterUserInput {
  tempUserId: string;
  email: string;
  password: string;
}

export interface LoginInput {
  email: string;
  password: string;
}

export interface AuthResponse {
  accessToken: string;
}



// eslint-disable-next-line @typescript-eslint/no-explicit-any
type AsyncReturnType<
T extends (...args: any) => Promise<any>
> = T extends (...args: any) => Promise<infer R> ? R : any;


export const appControllerGetHello = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axios.get(
      `/`,options
    );
  }


export const getAppControllerGetHelloQueryKey = () => [`/`];

    
export type AppControllerGetHelloQueryResult = NonNullable<AsyncReturnType<typeof appControllerGetHello>>
export type AppControllerGetHelloQueryError = AxiosError<unknown>

export const useAppControllerGetHello = <TData = AsyncReturnType<typeof appControllerGetHello>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<AsyncReturnType<typeof appControllerGetHello>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

  const queryFn: QueryFunction<AsyncReturnType<typeof appControllerGetHello>> = () => appControllerGetHello(axiosOptions);

  const query = useQuery<AsyncReturnType<typeof appControllerGetHello>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}


export const authControllerTempRegister = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    return axios.post(
      `/auth/temp-register`,undefined,options
    );
  }



    export type AuthControllerTempRegisterMutationResult = NonNullable<AsyncReturnType<typeof authControllerTempRegister>>
    
    export type AuthControllerTempRegisterMutationError = AxiosError<unknown>

    export const useAuthControllerTempRegister = <TError = AxiosError<unknown>,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof authControllerTempRegister>, TError,TVariables, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options || {}

      


      const mutationFn: MutationFunction<AsyncReturnType<typeof authControllerTempRegister>, TVariables> = () => {
          ;

          return  authControllerTempRegister(axiosOptions)
        }

      return useMutation<AsyncReturnType<typeof authControllerTempRegister>, TError, TVariables, TContext>(mutationFn, mutationOptions)
    }
    
export const authControllerLogin = (
    loginInput: LoginInput, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    return axios.post(
      `/auth/login`,
      loginInput,options
    );
  }



    export type AuthControllerLoginMutationResult = NonNullable<AsyncReturnType<typeof authControllerLogin>>
    export type AuthControllerLoginMutationBody = LoginInput
    export type AuthControllerLoginMutationError = AxiosError<unknown>

    export const useAuthControllerLogin = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof authControllerLogin>, TError,{data: LoginInput}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options || {}

      


      const mutationFn: MutationFunction<AsyncReturnType<typeof authControllerLogin>, {data: LoginInput}> = (props) => {
          const {data} = props || {};

          return  authControllerLogin(data,axiosOptions)
        }

      return useMutation<AsyncReturnType<typeof authControllerLogin>, TError, {data: LoginInput}, TContext>(mutationFn, mutationOptions)
    }
    
export const authControllerRegister = (
    registerUserInput: RegisterUserInput, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    return axios.post(
      `/auth/register`,
      registerUserInput,options
    );
  }



    export type AuthControllerRegisterMutationResult = NonNullable<AsyncReturnType<typeof authControllerRegister>>
    export type AuthControllerRegisterMutationBody = RegisterUserInput
    export type AuthControllerRegisterMutationError = AxiosError<unknown>

    export const useAuthControllerRegister = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof authControllerRegister>, TError,{data: RegisterUserInput}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options || {}

      


      const mutationFn: MutationFunction<AsyncReturnType<typeof authControllerRegister>, {data: RegisterUserInput}> = (props) => {
          const {data} = props || {};

          return  authControllerRegister(data,axiosOptions)
        }

      return useMutation<AsyncReturnType<typeof authControllerRegister>, TError, {data: RegisterUserInput}, TContext>(mutationFn, mutationOptions)
    }
    
export const authControllerGoogleAuth = (
    googleAuthInput: GoogleAuthInput, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    return axios.post(
      `/auth/google`,
      googleAuthInput,options
    );
  }



    export type AuthControllerGoogleAuthMutationResult = NonNullable<AsyncReturnType<typeof authControllerGoogleAuth>>
    export type AuthControllerGoogleAuthMutationBody = GoogleAuthInput
    export type AuthControllerGoogleAuthMutationError = AxiosError<unknown>

    export const useAuthControllerGoogleAuth = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof authControllerGoogleAuth>, TError,{data: GoogleAuthInput}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options || {}

      


      const mutationFn: MutationFunction<AsyncReturnType<typeof authControllerGoogleAuth>, {data: GoogleAuthInput}> = (props) => {
          const {data} = props || {};

          return  authControllerGoogleAuth(data,axiosOptions)
        }

      return useMutation<AsyncReturnType<typeof authControllerGoogleAuth>, TError, {data: GoogleAuthInput}, TContext>(mutationFn, mutationOptions)
    }
    
export const userControllerCurrentUser = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    return axios.get(
      `/users/current`,options
    );
  }


export const getUserControllerCurrentUserQueryKey = () => [`/users/current`];

    
export type UserControllerCurrentUserQueryResult = NonNullable<AsyncReturnType<typeof userControllerCurrentUser>>
export type UserControllerCurrentUserQueryError = AxiosError<unknown>

export const useUserControllerCurrentUser = <TData = AsyncReturnType<typeof userControllerCurrentUser>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<AsyncReturnType<typeof userControllerCurrentUser>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getUserControllerCurrentUserQueryKey();

  

  const queryFn: QueryFunction<AsyncReturnType<typeof userControllerCurrentUser>> = () => userControllerCurrentUser(axiosOptions);

  const query = useQuery<AsyncReturnType<typeof userControllerCurrentUser>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}


export const habitControllerFindAllByUserId = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Habit[]>> => {
    return axios.get(
      `/habits`,options
    );
  }


export const getHabitControllerFindAllByUserIdQueryKey = () => [`/habits`];

    
export type HabitControllerFindAllByUserIdQueryResult = NonNullable<AsyncReturnType<typeof habitControllerFindAllByUserId>>
export type HabitControllerFindAllByUserIdQueryError = AxiosError<unknown>

export const useHabitControllerFindAllByUserId = <TData = AsyncReturnType<typeof habitControllerFindAllByUserId>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<AsyncReturnType<typeof habitControllerFindAllByUserId>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getHabitControllerFindAllByUserIdQueryKey();

  

  const queryFn: QueryFunction<AsyncReturnType<typeof habitControllerFindAllByUserId>> = () => habitControllerFindAllByUserId(axiosOptions);

  const query = useQuery<AsyncReturnType<typeof habitControllerFindAllByUserId>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}


export const habitControllerCreateHabit = (
    createHabitInput: CreateHabitInput, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Habit>> => {
    return axios.post(
      `/habits`,
      createHabitInput,options
    );
  }



    export type HabitControllerCreateHabitMutationResult = NonNullable<AsyncReturnType<typeof habitControllerCreateHabit>>
    export type HabitControllerCreateHabitMutationBody = CreateHabitInput
    export type HabitControllerCreateHabitMutationError = AxiosError<unknown>

    export const useHabitControllerCreateHabit = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof habitControllerCreateHabit>, TError,{data: CreateHabitInput}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options || {}

      


      const mutationFn: MutationFunction<AsyncReturnType<typeof habitControllerCreateHabit>, {data: CreateHabitInput}> = (props) => {
          const {data} = props || {};

          return  habitControllerCreateHabit(data,axiosOptions)
        }

      return useMutation<AsyncReturnType<typeof habitControllerCreateHabit>, TError, {data: CreateHabitInput}, TContext>(mutationFn, mutationOptions)
    }
    
export const habitControllerUpdateHabitCompletedDates = (
    updateHabitCompletedDatesInput: UpdateHabitCompletedDatesInput, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Habit>> => {
    return axios.post(
      `/habits/update-completed-date`,
      updateHabitCompletedDatesInput,options
    );
  }



    export type HabitControllerUpdateHabitCompletedDatesMutationResult = NonNullable<AsyncReturnType<typeof habitControllerUpdateHabitCompletedDates>>
    export type HabitControllerUpdateHabitCompletedDatesMutationBody = UpdateHabitCompletedDatesInput
    export type HabitControllerUpdateHabitCompletedDatesMutationError = AxiosError<unknown>

    export const useHabitControllerUpdateHabitCompletedDates = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof habitControllerUpdateHabitCompletedDates>, TError,{data: UpdateHabitCompletedDatesInput}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options || {}

      


      const mutationFn: MutationFunction<AsyncReturnType<typeof habitControllerUpdateHabitCompletedDates>, {data: UpdateHabitCompletedDatesInput}> = (props) => {
          const {data} = props || {};

          return  habitControllerUpdateHabitCompletedDates(data,axiosOptions)
        }

      return useMutation<AsyncReturnType<typeof habitControllerUpdateHabitCompletedDates>, TError, {data: UpdateHabitCompletedDatesInput}, TContext>(mutationFn, mutationOptions)
    }
    
export const habitControllerEditHabit = (
    id: string,
    editHabitInput: EditHabitInput, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Habit>> => {
    return axios.put(
      `/habits/${id}`,
      editHabitInput,options
    );
  }



    export type HabitControllerEditHabitMutationResult = NonNullable<AsyncReturnType<typeof habitControllerEditHabit>>
    export type HabitControllerEditHabitMutationBody = EditHabitInput
    export type HabitControllerEditHabitMutationError = AxiosError<unknown>

    export const useHabitControllerEditHabit = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof habitControllerEditHabit>, TError,{id: string;data: EditHabitInput}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options || {}

      


      const mutationFn: MutationFunction<AsyncReturnType<typeof habitControllerEditHabit>, {id: string;data: EditHabitInput}> = (props) => {
          const {id,data} = props || {};

          return  habitControllerEditHabit(id,data,axiosOptions)
        }

      return useMutation<AsyncReturnType<typeof habitControllerEditHabit>, TError, {id: string;data: EditHabitInput}, TContext>(mutationFn, mutationOptions)
    }
    
export const habitControllerDeleteHabit = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.delete(
      `/habits/${id}`,options
    );
  }



    export type HabitControllerDeleteHabitMutationResult = NonNullable<AsyncReturnType<typeof habitControllerDeleteHabit>>
    
    export type HabitControllerDeleteHabitMutationError = AxiosError<Habit>

    export const useHabitControllerDeleteHabit = <TError = AxiosError<Habit>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof habitControllerDeleteHabit>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options || {}

      


      const mutationFn: MutationFunction<AsyncReturnType<typeof habitControllerDeleteHabit>, {id: string}> = (props) => {
          const {id} = props || {};

          return  habitControllerDeleteHabit(id,axiosOptions)
        }

      return useMutation<AsyncReturnType<typeof habitControllerDeleteHabit>, TError, {id: string}, TContext>(mutationFn, mutationOptions)
    }
    


export const getAuthControllerTempRegisterMock = () => ({accessToken: faker.random.word()})

export const getAuthControllerLoginMock = () => ({accessToken: faker.random.word()})

export const getAuthControllerRegisterMock = () => ({accessToken: faker.random.word()})

export const getAuthControllerGoogleAuthMock = () => ({accessToken: faker.random.word()})

export const getUserControllerCurrentUserMock = () => ({_id: faker.random.word(), email: faker.random.word(), password: faker.helpers.randomize([faker.random.word(), undefined]), isTemp: faker.datatype.boolean(), dateCreated: faker.datatype.number()})

export const getHabitControllerFindAllByUserIdMock = () => ([...Array(faker.datatype.number({min: 1, max: 10}))].map(() => ({_id: faker.random.word(), userId: faker.random.word(), title: faker.random.word(), isoWeekdays: [...Array(faker.datatype.number({min: 1, max: 10}))].map(() => (faker.datatype.number())), dateCreated: faker.datatype.number(), completedDates: [...Array(faker.datatype.number({min: 1, max: 10}))].map(() => (faker.datatype.number())), archived: faker.datatype.boolean()})))

export const getHabitControllerCreateHabitMock = () => ({_id: faker.random.word(), userId: faker.random.word(), title: faker.random.word(), isoWeekdays: [...Array(faker.datatype.number({min: 1, max: 10}))].map(() => (faker.datatype.number())), dateCreated: faker.datatype.number(), completedDates: [...Array(faker.datatype.number({min: 1, max: 10}))].map(() => (faker.datatype.number())), archived: faker.datatype.boolean()})

export const getHabitControllerUpdateHabitCompletedDatesMock = () => ({_id: faker.random.word(), userId: faker.random.word(), title: faker.random.word(), isoWeekdays: [...Array(faker.datatype.number({min: 1, max: 10}))].map(() => (faker.datatype.number())), dateCreated: faker.datatype.number(), completedDates: [...Array(faker.datatype.number({min: 1, max: 10}))].map(() => (faker.datatype.number())), archived: faker.datatype.boolean()})

export const getHabitControllerEditHabitMock = () => ({_id: faker.random.word(), userId: faker.random.word(), title: faker.random.word(), isoWeekdays: [...Array(faker.datatype.number({min: 1, max: 10}))].map(() => (faker.datatype.number())), dateCreated: faker.datatype.number(), completedDates: [...Array(faker.datatype.number({min: 1, max: 10}))].map(() => (faker.datatype.number())), archived: faker.datatype.boolean()})

export const getHabitAppMSW = () => [
rest.get('*', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
        )
      }),rest.post('*/auth/temp-register', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
ctx.json(getAuthControllerTempRegisterMock()),
        )
      }),rest.post('*/auth/login', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
ctx.json(getAuthControllerLoginMock()),
        )
      }),rest.post('*/auth/register', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
ctx.json(getAuthControllerRegisterMock()),
        )
      }),rest.post('*/auth/google', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
ctx.json(getAuthControllerGoogleAuthMock()),
        )
      }),rest.get('*/users/current', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
ctx.json(getUserControllerCurrentUserMock()),
        )
      }),rest.get('*/habits', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
ctx.json(getHabitControllerFindAllByUserIdMock()),
        )
      }),rest.post('*/habits', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
ctx.json(getHabitControllerCreateHabitMock()),
        )
      }),rest.post('*/habits/update-completed-date', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
ctx.json(getHabitControllerUpdateHabitCompletedDatesMock()),
        )
      }),rest.put('*/habits/:id', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
ctx.json(getHabitControllerEditHabitMock()),
        )
      }),rest.delete('*/habits/:id', (_req, res, ctx) => {
        return res(
          ctx.delay(1000),
          ctx.status(200, 'Mocked status'),
        )
      }),]
